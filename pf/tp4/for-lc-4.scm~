#!r6rs
(import (rnrs base) (rnrs io simple) (rnrs lists))

(define (writeln/return x)
  (write x)
  (newline)
  x)

(define (butlast-and-last l)
  ;;  Rappelons qu'ici, "l" est une liste linéaire non vide.
  (let ((first (car l))
	(rest (cdr l)))
    (if (null? rest)
	(values '() first)
	(call-with-values (lambda () (butlast-and-last rest))
	  (lambda (butlast-0 last-0)
	    (values (cons first butlast-0) last-0))))))

(define (butlast-and-last-v2 l)
  ;;  Seconde définition de cette fonction, en utilisant non pas la fonction
  ;;  "call-with-values", mais la forme spéciale "let-values".
  (let ((first (car l))
	(rest (cdr l)))
    (if (null? rest)
	(values '() first)
	(let-values (((butlast-0 last-0) (butlast-and-last-v2 rest)))
	  (values (cons first butlast-0) last-0)))))

(define (palindrome? l)
  (if (null? l)
      #t
      (let ((rest (cdr l)))
	(if (null? rest)
	    #t
	    (let-values (((butlast-0 last-0) (butlast-and-last rest)))
	      (and (equal? (car l) last-0) (palindrome? butlast-0)))))))

(define (take-while p1? l)
  (if (null? l)
      '()
      (let ((first (car l)))
	(if (p1? first) (cons first (take-while p1? (cdr l))) '()))))

(define (drop-while p1? l)
  (if (or (null? l) (not (p1? (car l)))) l (drop-while p1? (cdr l))))

(writeln/return (call-with-values (lambda () (values 'L 3)) cons))

(writeln/return (let ((a 'sure)
		      (b 'here)
		      (x 'little)
		      (y 'players))
		  (let-values (((a b) (values x y))
			       ((x y) (values a b)))
		    (list a b x y))))

(writeln/return (let ((a 'sure)
		      (b 'here)
		      (x 'little)
		      (y 'players))
		  (let*-values (((a b) (values x y))
				((x y) (values a b)))
		    (list a b x y))))

(writeln/return (let-values (((first) (car '(very little players)))
			     ((the-quotient the-remainder)
			      (div-and-mod 2000 9)))
		  (cons* the-quotient the-remainder first)))